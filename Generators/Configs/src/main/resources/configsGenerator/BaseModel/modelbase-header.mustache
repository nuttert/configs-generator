{{>licenseInfo}}
/*
 * ModelBase.h
 *
 * This is the base class for all model classes
 */

#pragma once

{{{defaultInclude}}}

#include <cpprest/details/basic_types.h>

#include <cpprest/json.h>
#include <vector>
#include <map>
#include <optional>

#ifdef GENRATE_POCO_DB
    #include <Poco/MongoDB/Element.h>
    #include <Poco/MongoDB/Array.h>
    #include <Poco/Data/TypeHandler.h>
#endif

#include <Poco/UUID.h>
#include <Poco/DateTime.h>

namespace Poco::Data{
    class Session;
}


namespace configs{

class {{declspec}} ModelBase
{
public:
    ModelBase();
    virtual ~ModelBase();

    virtual void validate() = 0;

    virtual web::json::value toJson() const = 0;
    virtual bool fromJson( const web::json::value& json) = 0;

    static std::string toString( const bool val );
    static std::string toString( const float val );
    static std::string toString( const double val );
    static std::string toString( const int32_t val );
    static std::string toString( const int64_t val );
    static std::string toString( const std::string &val );

    static std::string toString( const Poco::Timestamp &val );
    static std::string toString( const Poco::DateTime &val );
    static std::string toString( const Poco::UUID &val );

    static std::string toString( const web::json::value &val );
    template <typename T>
    static std::string toString( const std::shared_ptr<T>& val, bool postgresMode=false );
    template <typename T>
    static std::string toString( const std::optional<T>& val );
    template <typename T>
    static std::string toString( const std::vector<T> & val, bool postgresMode=false );
    template <typename T>
    static std::string toString( const std::map<std::string,T> & val);

    static web::json::value toJson( bool val );
    static web::json::value toJson( float val );
    static web::json::value toJson( double val );
    static web::json::value toJson( int32_t val );
    static web::json::value toJson( int64_t val );
    static web::json::value toJson( const std::string& val );

    static web::json::value toJson( const Poco::Timestamp& val );
    static web::json::value toJson( const Poco::DateTime& val );
    static web::json::value toJson( const Poco::UUID& val );

    static web::json::value toJson( const web::json::value& val );
    template<typename T>
    static web::json::value toJson( const std::shared_ptr<T>& val );
    template<typename T>
    static web::json::value toJson( const std::optional<T>& val );
    template<typename T>
    static web::json::value toJson( const std::vector<T>& val );
    template<typename T>
    static web::json::value toJson( const std::map<std::string, T>& val );

    static bool fromString( const std::string& val, bool & );
    static bool fromString( const std::string& val, float & );
    static bool fromString( const std::string& val, double & );
    static bool fromString( const std::string& val, int32_t & );
    static bool fromString( const std::string& val, int64_t & );
    static bool fromString( const std::string& val, std::string & );

    static bool fromString( const std::string& val, Poco::DateTime & );
    static bool fromString( const std::string& val, Poco::Timestamp  & );
    static bool fromString( const std::string& val, Poco::UUID & );

    static bool fromString( const std::string& val, web::json::value & );
    template<typename T>
    static bool fromString( const std::string& val, std::shared_ptr<T>& , bool postgresMode = false);
    template<typename T>
    static bool fromString( const std::string& val, std::optional<T>& );
    template<typename T>
    static bool fromString( const std::string& val, std::vector<T> &, bool postgresMode=false );
    template<typename T>
    static bool fromString( const std::string& val, std::map<std::string, T> & );

    static bool fromJson( const web::json::value& val, bool & );
    static bool fromJson( const web::json::value& val, float & );
    static bool fromJson( const web::json::value& val, double & );
    static bool fromJson( const web::json::value& val, int32_t & );
    static bool fromJson( const web::json::value& val, int64_t & );
    static bool fromJson( const web::json::value& val, std::string & );

    static bool fromJson( const web::json::value& val, Poco::DateTime  & );
    static bool fromJson( const web::json::value& val, Poco::Timestamp  & );
    static bool fromJson( const web::json::value& val, Poco::UUID & );

    static bool fromJson( const web::json::value& val, web::json::value & );
    template<typename T>
    static bool fromJson( const web::json::value& val, std::shared_ptr<T>& );
    template<typename T>
    static bool fromJson( const web::json::value& val, std::optional<T>& );
    template<typename T>
    static bool fromJson( const web::json::value& val, std::vector<T> & );
    template<typename T>
    static bool fromJson( const web::json::value& val, std::map<std::string, T> & );


    static std::string toBase64( std::string value );
    static std::string toBase64( std::shared_ptr<std::istream> value );
    static std::shared_ptr<std::istream> fromBase64( const std::string& encoded );

    private:
    mutable std::string buffer;
};
}

namespace configs{
template <typename T>
std::string ModelBase::toString( const std::shared_ptr<T>& val, bool postgresMode )
{
    utility::stringstream_t ss;
    if(val){
        val->toJson().serialize(ss);
    }
    return  std::string(ss.str());
}
template <typename T>
std::string ModelBase::toString( const std::optional<T>& val )
{
    utility::stringstream_t ss;
    if(val)
    {
        toJson(*val).serialize(ss);
    }
    return  std::string(ss.str());
}
template<typename T>
std::string ModelBase::toString( const std::vector<T> & val, bool postgresMode )
{
    std::string strArray = postgresMode ? "{" : "";
    for ( const auto &item : val )
    {
        strArray.append( toString(item) + "," );
    }
    if (val.size() > 0)
    {
        strArray.pop_back();
    }
    strArray += postgresMode ? "}" : "";
    return strArray;
}
template <typename T>
std::string ModelBase::toString( const std::map<std::string,T> & val)
{
    utility::stringstream_t ss;
    toJson(val).serialize(ss);
    return  std::string(ss.str());
}
template<typename T>
web::json::value ModelBase::toJson( const std::shared_ptr<T>& val)
{
    web::json::value retVal;
     if(val != nullptr){
         retVal = val->toJson();
     }
    return retVal;
}
template<typename T>
web::json::value ModelBase::toJson( const std::optional<T>& val )
{
    web::json::value retVal;
    if(val)
    {
        retVal = toJson(*val);
    }
    return retVal;
}
template<typename T>
web::json::value ModelBase::toJson( const std::vector<T>& value )
{
    std::vector<web::json::value> ret;
    for ( const auto& x : value )
    {
        ret.push_back( toJson(x) );
    }
    return web::json::value::array(ret);
}
template<typename T>
web::json::value ModelBase::toJson( const std::map<std::string, T>& val )
{
    web::json::value obj;
    for ( const auto &itemkey : val )
    {
        obj[itemkey.first] = toJson( itemkey.second );
    }
    return obj;
}
template<typename T>
bool ModelBase::fromString( const std::string& val, std::shared_ptr<T>& outVal , bool postgresMode)
{
    bool ok = false;
    if(outVal == nullptr)
    {
        outVal = std::shared_ptr<T>(new T());
    }    
    if( outVal != nullptr )
    {
       ok = outVal->fromJson(web::json::value::parse(val));
    }
    return ok;
}
template<typename T>
bool ModelBase::fromString( const std::string& val, std::optional<T>& outVal )
{
    bool ok = false;
    if(!outVal)
    {
        outVal = T();
    }    
    if( outVal )
    {
        ok = fromJson(web::json::value::parse(val), *outVal);
    }
    return ok;
}
template<typename T>
bool ModelBase::fromString( const std::string& val, std::vector<T>& outVal, bool postgresMode )
{
    if(postgresMode){
        auto substr = std::string(val);
        std::replace(substr.begin(), substr.end(), '{', '[');
        std::replace(substr.begin(), substr.end(), '}', ']');
        substr = "[" + substr+ "]";
        auto result = fromJson(web::json::value::parse(substr), outVal);
        return result;
    }
    return  fromJson(web::json::value::parse(val), outVal);
}
template<typename T>
bool ModelBase::fromString( const std::string& val, std::map<std::string, T> & outVal){
    return fromJson(web::json::value::parse(val), outVal);
}

template<typename T>
bool ModelBase::fromJson( const web::json::value& val, std::shared_ptr<T> &outVal )
{
    bool ok = false;
    if(outVal == nullptr)
    {
        outVal = std::shared_ptr<T>(new T());
    }
    if( outVal != nullptr )
    {
        ok = outVal->fromJson(val);
    }
    return ok;
}
template<typename T>
bool ModelBase::fromJson( const web::json::value& val, std::optional<T> &outVal )
{
    bool ok = false;
    if(!outVal)
    {
        outVal = T();
    }
    if(outVal)
    {
        ok = fromJson(val,*outVal);
    }
    return ok;
}
template<typename T>
bool ModelBase::fromJson( const web::json::value& val, std::vector<T> &outVal )
{
    bool ok = true;
    if (val.is_array())
    {
        for (const auto& jitem : val.as_array())
        {
            T item;
            ok &= fromJson(jitem, item);
            outVal.push_back(item);
        }
    }
    else
    {
        ok = false;
    }
    return ok;
}
template<typename T>
bool ModelBase::fromJson( const web::json::value& jval, std::map<std::string, T> &outVal )
{
    bool ok = true;
    if ( jval.is_object() )
    {
        auto obj = jval.as_object();
        for( auto objItr = obj.begin() ; objItr != obj.end() ; objItr++ )
        {
            T itemVal;
            ok &= fromJson(objItr->second, itemVal);
            outVal.insert(std::pair<std::string, T>(objItr->first, itemVal));
        }
    }
    else
    {
        ok = false;
    }
    return ok;
}
} //configs


