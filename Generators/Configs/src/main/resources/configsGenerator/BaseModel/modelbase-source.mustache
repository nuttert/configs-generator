{{>licenseInfo}}
#include "base-model.hpp"

#include "Poco/Timestamp.h"
#include "Poco/Timezone.h"
#include "Poco/DateTimeParser.h"
#include "Poco/DateTimeFormatter.h"
#include "Poco/DateTimeFormat.h"

namespace configs{

ModelBase::ModelBase()
{
}
ModelBase::~ModelBase()
{
}
std::string ModelBase::toString( const bool val )
{
    utility::stringstream_t ss;
    ss << val;
    return std::string(ss.str());
}
std::string ModelBase::toString( const float val )
{
    utility::stringstream_t ss;
    ss << val;
    return std::string(ss.str());
}
std::string ModelBase::toString( const double val )
{
    utility::stringstream_t ss;
    ss << val;
    return std::string(ss.str());
}
std::string ModelBase::toString( const int32_t val )
{
    utility::stringstream_t ss;
    ss << val;
    return std::string(ss.str());
}
std::string ModelBase::toString( const int64_t val )
{
    utility::stringstream_t ss;
    ss << val;
    return std::string(ss.str());
}
std::string ModelBase::toString (const std::string &val )
{
    utility::stringstream_t ss;
    ss << val;
    return std::string(ss.str());
}

std::string ModelBase::toString( const Poco::Timestamp &val ){
    std::string str = Poco::DateTimeFormatter::format(val, Poco::DateTimeFormat::ISO8601_FORMAT);
    return str;
}
std::string ModelBase::toString( const Poco::DateTime &val ){
    std::string str = Poco::DateTimeFormatter::format(val, Poco::DateTimeFormat::ISO8601_FORMAT);
    return str;
}
std::string ModelBase::toString( const Poco::UUID &val ){
    return val.toString();
}

std::string ModelBase::toString( const web::json::value &val )
{
    return val.serialize();
}
web::json::value ModelBase::toJson(bool value)
{
    return web::json::value::boolean(value);
}
web::json::value ModelBase::toJson( float value )
{
    return web::json::value::number(value);
}
web::json::value ModelBase::toJson( double value )
{
    return web::json::value::number(value);
}
web::json::value ModelBase::toJson( int32_t value )
{
    return web::json::value::number(value);
}
web::json::value ModelBase::toJson( int64_t value )
{
    return web::json::value::number(value);
}
web::json::value ModelBase::toJson( const std::string& value )
{
    return web::json::value::string(value);
}

web::json::value ModelBase::toJson( const Poco::Timestamp& val ){
    std::string str =  Poco::DateTimeFormatter::format(val, Poco::DateTimeFormat::ISO8601_FORMAT);
    return web::json::value::string(str);
}
web::json::value ModelBase::toJson( const Poco::DateTime& val ){
    std::string str =  Poco::DateTimeFormatter::format(val, Poco::DateTimeFormat::ISO8601_FORMAT);
    return web::json::value::string(str);
}
web::json::value ModelBase::toJson( const Poco::UUID& val ){
    return web::json::value::string(val.toString());
}

web::json::value ModelBase::toJson( const web::json::value& value )
{
    return value;
}
bool ModelBase::fromString( const std::string& val, bool &outVal )
{
    utility::stringstream_t ss(val);
    bool success = true;
    try
    {
        ss >> outVal;
    }
    catch (...)
    {
        success = false;
    }
    return success;
}
bool ModelBase::fromString( const std::string& val, float &outVal )
{
    utility::stringstream_t ss(val);
    bool success = true;
    try
    {
        ss >> outVal;
    }
    catch (...)
    {
        success = false;
    }
    return success;
}
bool ModelBase::fromString( const std::string& val, double &outVal )
{
    utility::stringstream_t ss(val);
    bool success = true;
    try
    {
        ss >> outVal;
    }
    catch (...)
    {
        success = false;
    }
    return success;
}
bool ModelBase::fromString( const std::string& val, int32_t &outVal )
{
    utility::stringstream_t ss(val);
    bool success = true;
    try
    {
        ss >> outVal;
    }
    catch (...)
    {
        success = false;
    }
    return success;
}
bool ModelBase::fromString( const std::string& val, int64_t &outVal )
{
    utility::stringstream_t ss(val);
    bool success = true;
    try
    {
        ss >> outVal;
    }
    catch (...)
    {
        success = false;
    }
    return success;
}
bool ModelBase::fromString( const std::string& val, std::string &outVal )
{
    utility::stringstream_t ss(val);
    bool success = true;
    try
    {
        ss >> outVal;
    }
    catch (...)
    {
        success = false;
    }
    return success;
}

bool ModelBase::fromString( const std::string& val, Poco::DateTime & dateTime){
    int timeZoneDifferential;
    return Poco::DateTimeParser::tryParse(
    Poco::DateTimeFormat::ISO8601_FORMAT, val, dateTime, timeZoneDifferential);
}
bool ModelBase::fromString( const std::string& val, Poco::Timestamp  & timestamp){
    int timeZoneDifferential;
    Poco::DateTime dt;
    bool ok = Poco::DateTimeParser::tryParse(
    Poco::DateTimeFormat::ISO8601_FORMAT, val, dt, timeZoneDifferential);
    timestamp = dt.timestamp();
    return ok;
}
bool ModelBase::fromString( const std::string& val, Poco::UUID & uuid){
    return uuid.tryParse(val);
}

bool ModelBase::fromString( const std::string& val, web::json::value &outVal )
{
    outVal = web::json::value::parse(val);
    return !outVal.is_null();
}
bool ModelBase::fromJson( const web::json::value& val, bool & outVal )
{
    outVal = !val.is_boolean() ? false : val.as_bool();
    return val.is_boolean();
}
bool ModelBase::fromJson( const web::json::value& val, float & outVal )
{
    outVal = !val.is_double() ? std::numeric_limits<float>::quiet_NaN(): static_cast<float>(val.as_double());
    return val.is_double();
}
bool ModelBase::fromJson( const web::json::value& val, double & outVal )
{
    outVal = !val.is_double() ? std::numeric_limits<double>::quiet_NaN(): val.as_double();
    return val.is_double() ;
}
bool ModelBase::fromJson( const web::json::value& val, int32_t & outVal )
{
    outVal = !val.is_integer() ? std::numeric_limits<int32_t>::quiet_NaN() : val.as_integer();
    return val.is_integer();
}
bool ModelBase::fromJson( const web::json::value& val, int64_t & outVal )
{
    outVal = val.is_null() ? std::numeric_limits<int64_t>::quiet_NaN() : val.as_number().to_int64();
    return val.is_number();
}
bool ModelBase::fromJson( const web::json::value& val, std::string & outVal )
{
    outVal = val.is_string() ? val.as_string() : utility::conversions::to_string_t("");
    return val.is_string();
}

bool ModelBase::fromJson( const web::json::value& val, Poco::DateTime  & outVal){
    bool ok = true;
    int timeZoneDifferential;
    if(!val.is_null())
    ok = Poco::DateTimeParser::tryParse(Poco::DateTimeFormat::ISO8601_FORMAT, val.as_string(), outVal, timeZoneDifferential);
    else  Poco::DateTimeParser::parse(Poco::DateTimeFormat::ISO8601_FORMAT, "NULL", outVal, timeZoneDifferential);    
    return ok;
}
bool ModelBase::fromJson( const web::json::value& val, Poco::Timestamp  & outVal){
    bool ok = true;
    int timeZoneDifferential;
    Poco::DateTime  dt;
    if(!val.is_null()) 
    ok = Poco::DateTimeParser::tryParse(Poco::DateTimeFormat::ISO8601_FORMAT, val.as_string(), dt, timeZoneDifferential);
    else  Poco::DateTimeParser::parse(Poco::DateTimeFormat::ISO8601_FORMAT, "NULL", dt, timeZoneDifferential);  
    outVal = dt.timestamp();
    return ok;
}
bool ModelBase::fromJson( const web::json::value& val, Poco::UUID & outVal){
    bool ok = true;
    if(!val.is_null()) ok = outVal.tryParse(val.as_string());
    else outVal.parse("NULL");  
    return ok;
}

bool ModelBase::fromJson( const web::json::value& val, web::json::value & outVal )
{
    outVal = val;
    return !val.is_null();
}

// base64 encoding/decoding based on : https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64#C.2B.2B
const static char Base64Chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const static char Base64PadChar = '=';
std::string ModelBase::toBase64( std::string value )
{
    std::shared_ptr<std::istream> source( new std::stringstream( utility::conversions::to_utf8string(value) ) );
    return ModelBase::toBase64(source);
}
std::string ModelBase::toBase64( std::shared_ptr<std::istream> value )
{
    value->seekg( 0, value->end );
    size_t length = value->tellg();
    value->seekg( 0, value->beg );
    std::string base64;
    base64.reserve( ((length / 3) + (length % 3 > 0)) * 4 );
    char read[3] = { 0 };
    uint32_t temp;
    for ( size_t idx = 0; idx < length / 3; idx++ )
    {
        value->read( read, 3 );
        temp = (read[0]) << 16;
        temp += (read[1]) << 8;
        temp += (read[2]);
        base64.append( 1, Base64Chars[(temp & 0x00FC0000) >> 18] );
        base64.append( 1, Base64Chars[(temp & 0x0003F000) >> 12] );
        base64.append( 1, Base64Chars[(temp & 0x00000FC0) >> 6] );
        base64.append( 1, Base64Chars[(temp & 0x0000003F)] );
    }
    switch ( length % 3 )
    {
        case 1:
            value->read( read, 1 );
            temp = read[0] << 16;
            base64.append( 1, Base64Chars[(temp & 0x00FC0000) >> 18] );
            base64.append( 1, Base64Chars[(temp & 0x0003F000) >> 12] );
            base64.append( 2, Base64PadChar );
            break;
        case 2:
            value->read( read, 2 );
            temp = read[0] << 16;
            temp += read[1] << 8;
            base64.append( 1, Base64Chars[(temp & 0x00FC0000) >> 18] );
            base64.append( 1, Base64Chars[(temp & 0x0003F000) >> 12] );
            base64.append( 1, Base64Chars[(temp & 0x00000FC0) >> 6] );
            base64.append( 1, Base64PadChar );
            break;
    }
    return base64;
}
std::shared_ptr<std::istream> ModelBase::fromBase64( const std::string& encoded )
{
    std::shared_ptr<std::stringstream> result(new std::stringstream);

    char outBuf[3] = { 0 };
    uint32_t temp = 0;

    std::string::const_iterator cursor = encoded.begin();
    while ( cursor < encoded.end() )
    {
        for ( size_t quantumPosition = 0; quantumPosition < 4; quantumPosition++ )
        {
            temp <<= 6;
            if ( *cursor >= 0x41 && *cursor <= 0x5A )
            {
                temp |= *cursor - 0x41;
            }
            else if ( *cursor >= 0x61 && *cursor <= 0x7A )
            {
                temp |= *cursor - 0x47;
            }
            else if ( *cursor >= 0x30 && *cursor <= 0x39 )
            {
                temp |= *cursor + 0x04;
            }
            else if ( *cursor == 0x2B )
            {
                temp |= 0x3E; //change to 0x2D for URL alphabet
            }
            else if ( *cursor == 0x2F )
            {
                temp |= 0x3F; //change to 0x5F for URL alphabet
            }
            else if ( *cursor == Base64PadChar ) //pad
            {
                switch ( encoded.end() - cursor )
                {
                    case 1: //One pad character
                        outBuf[0] = (temp >> 16) & 0x000000FF;
                        outBuf[1] = (temp >> 8) & 0x000000FF;
                        result->write( outBuf, 2 );
                        return result;
                    case 2: //Two pad characters
                        outBuf[0] = (temp >> 10) & 0x000000FF;
                        result->write( outBuf, 1 );
                        return result;
                    default:
                        throw web::json::json_exception( utility::conversions::to_string_t( "Invalid Padding in Base 64!" ).c_str() );
                }
            }
            else
            {
                throw web::json::json_exception( utility::conversions::to_string_t( "Non-Valid Character in Base 64!" ).c_str() );
            }
            ++cursor;
        }

        outBuf[0] = (temp >> 16) & 0x000000FF;
        outBuf[1] = (temp >> 8) & 0x000000FF;
        outBuf[2] = (temp) & 0x000000FF;
        result->write( outBuf, 3 );
    }

    return result;
}
} //configs
