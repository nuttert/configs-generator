{{#models}}{{#model}}{{^isConfig}}
#include "{{classname}}.hpp"
#ifdef GENRATE_POCO_DB
#include <Poco/Data/Session.h>
#include "Poco/Data/DataException.h"
#include "Poco/Data/PostgreSQL/PostgreSQLException.h"
#endif
#include <regex> 
#include "log.hh"
#include <boost/algorithm/string/replace.hpp>
{{#vendorExtensions.x-dependednt-model}}
{{#vendorExtensions.x-shared-ptr-imports}}
{{{.}}}
{{/vendorExtensions.x-shared-ptr-imports}}
{{/vendorExtensions.x-dependednt-model}}

namespace{
    web::json::value fromString(std::string const &input) {    
        utility::stringstream_t stream;
        stream << input;
        web::json::value ret = web::json::value::parse(stream);
        return ret;
    }
}

namespace {{#modelNamespaceDeclarations}}{{this}}{{^-last}}::{{/-last}}{{/modelNamespaceDeclarations}}{


{{#vendorExtensions.x-mongo}}
using bsoncxx::builder::stream::document;



bsoncxx::stdx::optional<mongocxx::result::insert_one>
 {{classname}}::insertToMongo(mongocxx::collection& collection){
    auto doc_value = bsoncxx::from_json(toString(toJson()));
    auto result = collection.insert_one(doc_value.view());
    return result;
}

    
bsoncxx::stdx::optional<mongocxx::result::insert_many>
 {{classname}}::insertToMongoBulk(mongocxx::collection& collection,
                                   const std::vector<{{classname}}>& objects){
        std::vector<bsoncxx::document::view> documents{};
        for(const auto& obj:objects){
            auto doc_value = bsoncxx::from_json(toString(obj.toJson()));
            documents.push_back(doc_value.view());
        }
            
        auto result = collection.insert_many(documents);
        return result;                               
    }

bool {{classname}}::fillFromMongo(mongocxx::collection& collection,
                        const bsoncxx::document::view& filter,
                        const mongocxx::options::find& options){
   auto doc = collection.find_one(filter,options);
   if(!doc) return false;
   std::string json_string = bsoncxx::to_json(*doc);
   return fromJson(::fromString(std::move(json_string)));
}



std::vector<std::shared_ptr<{{classname}}>> {{classname}}::fillFromMongoBulk(mongocxx::collection& collection,
                        const bsoncxx::document::view& filter,
                        const mongocxx::options::find& options){
        auto cursor = collection.find(filter,options);
        bool ok = true;
        auto objects = std::vector<std::shared_ptr<{{classname}}>>();
        for(auto doc : cursor) {
             std::string json_string = bsoncxx::to_json(doc);
             std::shared_ptr<{{classname}}> object = std::make_shared<{{classname}}>();
             ok &= object->fromJson(::fromString(std::move(json_string)));
             if(!ok) throw std::runtime_error("Can not convert mongo db object to {{classname}}");
             objects.push_back(object);
        }
        return objects;
    }

bsoncxx::stdx::optional<mongocxx::result::update>
 {{classname}}::updateMongo(mongocxx::collection& collection,
                    const bsoncxx::document::view& filter,
                    decltype(document{} << "$set") update){
                auto doc_value = bsoncxx::from_json(toString(toJson()));
                auto result = collection.update_one(filter, update << doc_value << finalize);
                return result;
            }

{{/vendorExtensions.x-mongo}}

{{#vendorExtensions.x-postgres-table-name}}
Poco::Data::Statement {{classname}}::insertToPostgres(std::shared_ptr<Poco::Data::Session> psql_client){
    auto insert_client = Poco::Data::Statement(*psql_client);
    insert_client << "INSERT INTO {{vendorExtensions.x-postgres-table-name}} VALUES ({{postgresValuesIndexies}});", Poco::Data::Keywords::use(*this);
    return insert_client;
}
Poco::Data::Statement {{classname}}::fillFromPostgres(std::shared_ptr<Poco::Data::Session> psql_client,
                                        std::optional<std::string> select,
                                        std::optional<std::string> where){
    auto select_client = Poco::Data::Statement(*psql_client);
    if(!select) select = "*";
    {{#vendorExtensions.x-postgres}}
    {{#vars}}
    {{#required}}
    {{#vendorExtensions.x-postgres-ref}}
    {{#isString}}
    if(!where) where =  "{{#snakecase}}{{name}}{{/snakecase}}="+"\""+{{#snakecase}}{{name}}{{/snakecase}}+"\"";
    {{/isString}}
    {{#isNumeric}}
    if(!where) where =  "{{#snakecase}}{{name}}{{/snakecase}}="+std::to_string({{#snakecase}}{{name}}{{/snakecase}});
    {{/isNumeric}}
    {{/vendorExtensions.x-postgres-ref}}
    {{/required}}
    {{/vars}}
    if(*where != "") where = "WHERE "+ *where;
    {{/vendorExtensions.x-postgres}}
    select_client << fmt::format("SELECT {} FROM {{vendorExtensions.x-postgres-table-name}} {};",*select, *where), 
        Poco::Data::Keywords::into(*this),
        Poco::Data::Keywords::lowerLimit(1),
        Poco::Data::Keywords::upperLimit(1);
    return select_client;
}
{{/vendorExtensions.x-postgres-table-name}}


{{#isEnum}}

{{classname}}::{{classname}}()
{
}
{{classname}}::{{classname}}(const e{{classname}} value){
    setValue(value);
}

{{classname}}::~{{classname}}()
{
}

void {{classname}}::validate()
{
    // TODO: implement validation
}

 bool {{classname}}::operator==(const e{{classname}} rhs) const{
     return value == rhs;
 }

web::json::value {{classname}}::toJson() const
{
    web::json::value val = web::json::value::object();

    {{#allowableValues}}{{#enumVars}}
    if (this->value == e{{classname}}::k{{{name}}}) val = web::json::value::string(U({{{value}}}));{{/enumVars}}{{/allowableValues}}

    return val;
}

bool {{classname}}::fromJson(const web::json::value& val)
{
    auto s = val.as_string();
    boost::replace_all(s, "%20", " ");

    {{#allowableValues}}{{#enumVars}}
    {{^-first}}else {{/-first}}if (s == utility::conversions::to_string_t({{{value}}})) this->value = e{{classname}}::k{{{name}}};{{/enumVars}}{{/allowableValues}}
    else{
        logError("Incorrect value: '{}' not in e{{classname}}", s);
        return false;
    }
    return true;
}
std::string {{classname}}::toString()
{
    std::string s;

    {{#allowableValues}}{{#enumVars}}
    if (this->value == e{{classname}}::k{{{name}}}) s = {{{value}}};{{/enumVars}}{{/allowableValues}}
    return s;
}

{{#vars}}
{{^isInherited}}
{{#isEnum}}
web::json::value toJson(const {{#camelcase}}e{{name}}{{/camelcase}} inp_value)
{
    web::json::value val = web::json::value::object();

    {{#allowableValues}}{{#enumVars}}
    if (inp_value == e{{classname}}::k{{{name}}}) val = web::json::value::string(U({{{value}}}));{{/enumVars}}{{/allowableValues}}

    return val;
}
bool fromJson({{#camelcase}}e{{name}}{{/camelcase}}& inp_value, const web::json::value& val)
{
    auto s = val.as_string();
    boost::replace_all(s, "%20", " ");

    {{#allowableValues}}{{#enumVars}}
    {{^-first}}else {{/-first}}if (s == utility::conversions::to_string_t({{{value}}})) inp_value = e{{classname}}::k{{{name}}};{{/enumVars}}{{/allowableValues}}
    else{
        logError("Incorrect value: '{}' not in e{{classname}}", s);
        return false;
    }
    return true;
}
{{/isEnum}}
{{/isInherited}}
{{/vars}}


{{classname}}::e{{classname}} {{classname}}::getValue() const
{
   return this->value;
}

void {{classname}}::setValue({{classname}}::e{{classname}} const value)
{
   this->value = value;
}

{{/isEnum}}

{{^isEnum}}

{{^oneOf}}
{{classname}}::{{classname}}()
{
    {{#vars}}
    {{^isEnum}}
    {{#required}}
    {{^isInherited}}
    {{^isContainer}}
    {{#isPrimitiveType}}
    {{#snakecase}}{{name}}{{/snakecase}} = {{{defaultValue}}};
    {{/isPrimitiveType}}
    {{^isPrimitiveType}}
    {{#isString}}
    {{#snakecase}}{{name}}{{/snakecase}} = {{{defaultValue}}};
    {{/isString}}
    {{#isDateTime}}
    {{#snakecase}}{{name}}{{/snakecase}} = {{{defaultValue}}};
    {{/isDateTime}}
    {{/isPrimitiveType}}
    {{/isContainer}}
    {{/isInherited}}
    {{/required}}
    {{^required}}
    {{^isContainer}}
    {{/isContainer}}
    {{/required}}
    {{/isEnum}}
    {{/vars}}
}

{{classname}}::~{{classname}}()
{
}

void {{classname}}::validate()
{
    // TODO: implement validation
}

web::json::value {{classname}}::toJson() const
{
    web::json::value val = web::json::value::object();
    {{#allParents}}
    {
        auto parent_val = this->{{.}}::toJson().as_object();
        for(const auto&[name, value]: parent_val)
            val[name] = value;
    }
    {{/allParents}}
   
    {{#vars}}{{^isInherited}}
    {{^isEnum}}
    {{^required}}
    {{^isContainer}}
    if({{#snakecase}}{{name}}{{/snakecase}})
    {
        val[utility::conversions::to_string_t("{{baseName}}")] = ModelBase::toJson({{#snakecase}}{{name}}{{/snakecase}});
    }
    {{/isContainer}}
    {{#isContainer}}
    if(!{{#snakecase}}{{name}}{{/snakecase}}.empty())
    {
        val[utility::conversions::to_string_t("{{baseName}}")] = ModelBase::toJson({{#snakecase}}{{name}}{{/snakecase}});
    }
    {{/isContainer}}
    {{/required}}{{/isEnum}}{{/isInherited}}{{/vars}}
    {{#vars}}{{^isInherited}}{{^isEnum}}
    {{#required}}val[utility::conversions::to_string_t("{{baseName}}")] = ModelBase::toJson({{#snakecase}}{{name}}{{/snakecase}});
    {{/required}}{{/isEnum}}{{/isInherited}}{{/vars}}
    {{#vars}}{{^isInherited}}
    {{#isEnum}}
    {{^required}}
    if({{#snakecase}}{{name}}{{/snakecase}})
    {
        {{#allowableValues}}{{#enumVars}}
        if (*{{#snakecase}}{{baseName}}{{/snakecase}} == {{#camelcase}}e_{{baseName}}{{/camelcase}}::k{{{name}}}) val[utility::conversions::to_string_t("{{baseName}}")] = web::json::value::string(U({{{value}}}));{{/enumVars}}{{/allowableValues}}
    }
    {{/required}}
    {{#required}}
    {{#allowableValues}}{{#enumVars}}
    if ({{#snakecase}}{{baseName}}{{/snakecase}} == {{#camelcase}}e_{{baseName}}{{/camelcase}}::k{{{name}}}) val[utility::conversions::to_string_t("{{baseName}}")] = web::json::value::string(U({{{value}}}));{{/enumVars}}{{/allowableValues}}
    {{/required}}
    {{/isEnum}}
    {{/isInherited}}{{/vars}}
    return val;
}

bool {{classname}}::fromJson(const web::json::value& val)
{
    bool ok = true;
    {{#allParents}}
    ok &= this->{{.}}::fromJson(val);
    {{/allParents}}

    {{#vars}}{{^isEnum}}{{^required}}
    {{^isInherited}}
    if(val.has_field(utility::conversions::to_string_t("{{baseName}}")))
    {
        bool local_ok = true;
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("{{baseName}}"));
        if(!fieldValue.is_null())
        {
            {{{dataType}}} refVal_{{#snakecase}}{{baseName}}{{/snakecase}};
            local_ok = ModelBase::fromJson(fieldValue, refVal_{{#snakecase}}{{baseName}}{{/snakecase}});
            ok &= local_ok;
            {{setter}}(std::move(refVal_{{#snakecase}}{{baseName}}{{/snakecase}}));
        }
        if(!local_ok){
            logWarn("{{baseName}} field parsing error in {{classname}} or std::variant trying(this is ok)");
            ok = false;
        }
    }
    {{/isInherited}}{{/required}}
    {{#required}}
    try{
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("{{baseName}}"));
        bool local_ok = true;
        if(!fieldValue.is_null())
        {
            {{{dataType}}} refVal_{{#snakecase}}{{baseName}}{{/snakecase}};
            local_ok = ModelBase::fromJson(fieldValue, refVal_{{#snakecase}}{{baseName}}{{/snakecase}});
            ok &= local_ok;
            {{setter}}(std::move(refVal_{{#snakecase}}{{baseName}}{{/snakecase}}));
        }else{
            logWarn("{{baseName}} is required filed in config {{classname}} or std::variant trying(this is ok)");
            throw std::runtime_error("{{baseName}} is required filed in config {{classname}}");
        }
        if(!local_ok){
            logWarn("{{baseName}} field parsing error in {{classname}} or std::variant trying(this is ok)");
            ok = false;
        }
    }catch(std::exception& e){
        logWarn("std::variant trying(this is ok) or required field {{baseName}} not found in {{classname}} : {}",e.what());
        ok = false;
    }
    {{/required}}{{/isEnum}}{{/vars}}

    {{#vars}}{{^isInherited}}
    {{#isEnum}}
    {{^required}}
    try{
    if(val.has_field(utility::conversions::to_string_t("{{baseName}}")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("{{baseName}}"));
        if(!fieldValue.is_null())
        {
            auto value_str_{{#snakecase}}{{baseName}}{{/snakecase}} = fieldValue.as_string();
            {{#allowableValues}}{{#enumVars}}
            {{^-first}}else {{/-first}}if (value_str_{{#snakecase}}{{baseName}}{{/snakecase}} == utility::conversions::to_string_t({{{value}}})) {{#snakecase}}{{baseName}}{{/snakecase}} = {{#camelcase}}e_{{baseName}}{{/camelcase}}::k{{{name}}};{{/enumVars}}{{/allowableValues}}
            else{
                logWarn("Can't convert string '{}' to enum class '{{#snakecase}}{{baseName}}{{/snakecase}}' or std::variant trying(this is ok)",value_str_{{#snakecase}}{{baseName}}{{/snakecase}});
                ok = false;
            }
        }
    }
    }catch(std::exception& e){
        logWarn("std::variant trying(this is ok) or field {{baseName}} in {{classname}}parsing error : {}",e.what());
        ok = false;
    }
    {{/required}}
    {{#required}}
    try{
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("{{baseName}}"));
        if(!fieldValue.is_null())
        {
            auto value_str_{{#snakecase}}{{baseName}}{{/snakecase}} = fieldValue.as_string();
            {{#allowableValues}}{{#enumVars}}
            {{^-first}}else {{/-first}}if (value_str_{{#snakecase}}{{baseName}}{{/snakecase}} == utility::conversions::to_string_t({{{value}}})) {{#snakecase}}{{baseName}}{{/snakecase}} = {{#camelcase}}e_{{baseName}}{{/camelcase}}::k{{{name}}};{{/enumVars}}{{/allowableValues}}
            else{
                logWarn("Can't convert string '{}' to enum class {{#snakecase}}{{baseName}}{{/snakecase}} or std::variant trying(this is ok)",value_str_{{#snakecase}}{{baseName}}{{/snakecase}});
                ok = false;
            }
        }else{
            logWarn("{{baseName}} is required filed in config {{classname}} or std::varint trying(this is ok)");
            throw std::runtime_error("{{baseName}} is required filed in config {{classname}}");
        }
    }catch(std::exception& e){
        logError("std::variant trying(this is ok) or required field {{baseName}} not found in {{classname}} : {}",e.what());
        ok = false;
    }
    {{/required}}
    {{/isEnum}}
    {{/isInherited}}{{/vars}}
   
    return ok;
}

{{#vars}}
{{#vendorExtensions.x-postgres-ref}}
const {{{dataType}}}& {{classname}}::GetPostgresRef() const{
    {{^isNumeric}}
    {{^isString}}
    static_assert(false, "{{#snakecase}}{{name}}{{/snakecase}} in {{classname}} is not primitive type - for postgres reference variable have to be primitive!");
    {{/isString}}
    {{/isNumeric}}
    {{^required}}
    static_assert(false, "{{#snakecase}}{{name}}{{/snakecase}} in {{classname}} is not required type - for postgres reference variable have to be required!");
    {{/required}}
    {{#isString}}
    {{#required}}
    return {{#snakecase}}{{name}}{{/snakecase}};
    {{/required}}
    {{/isString}}
    {{#isNumeric}}
    {{#required}}
    return {{#snakecase}}{{name}}{{/snakecase}};
    {{/required}}
    {{/isNumeric}}
}
{{{dataType}}}& {{classname}}::GetPostgresRef(){
    {{^isNumeric}}
    {{^isString}}
    static_assert(false, "{{#snakecase}}{{name}}{{/snakecase}} in {{classname}} is not primitive type - for postgres reference variable have to be primitive!");
    {{/isString}}
    {{/isNumeric}}
    {{^required}}
    static_assert(false, "{{#snakecase}}{{name}}{{/snakecase}} in {{classname}} is not required type - for postgres reference variable have to be required!");
    {{/required}}
    {{#isString}}
    {{#required}}
    return {{#snakecase}}{{name}}{{/snakecase}};
    {{/required}}
    {{/isString}}
    {{#isNumeric}}
    {{#required}}
    return {{#snakecase}}{{name}}{{/snakecase}};
    {{/required}}
    {{/isNumeric}}
}
{{/vendorExtensions.x-postgres-ref}}
{{^isInherited}}{{^isEnum}}
{{#isContainer}}
{{{dataType}}}& {{classname}}::{{getter}}()
{
    return {{#snakecase}}{{name}}{{/snakecase}};
}{{/isContainer}}
{{^isContainer}}{{^required}}{{#optional}}{{{dataType}}}{{/optional}}{{/required}}{{#required}}{{{dataType}}}{{/required}}  {{classname}}::{{getter}}() const
{
    return {{#snakecase}}{{name}}{{/snakecase}};
}
{{/isContainer}}

{{#isPrimitiveType}}
void {{classname}}::{{setter}}({{^required}}{{#optional}}{{{dataType}}}{{/optional}}{{/required}}{{#required}}{{{dataType}}}{{/required}} value)
{{/isPrimitiveType}}
{{^isPrimitiveType}}
void {{classname}}::{{setter}}(const 
    {{^isInherited}}
    {{^isEnum}}
    {{^required}}{{^isContainer}}{{#optional}}{{{dataType}}}{{/optional}}{{/isContainer}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{/required}}{{#required}}{{{dataType}}}{{/required}}
    {{/isEnum}}
    {{#isEnum}}
    {{^required}}{{#optional}}{{#camelcase}}e{{name}}{{/camelcase}}{{/optional}}{{/required}}{{#required}}{{#camelcase}}e{{name}}{{/camelcase}}{{/required}}
    {{/isEnum}}
    {{/isInherited}}
    & value)
{{/isPrimitiveType}}
{
    {{#isNumeric}}
    {{#maximum}}
    if(value > {{maximum}}) throw std::runtime_error(std::string("Value more than maximum {{maximum}}! See yaml docs"));
    {{/maximum}}
    {{#minimum}}
    if(value < {{minimum}}) throw std::runtime_error(std::string("Value less than minimum {{minimum}}! See yaml docs"));
    {{/minimum}}
    {{/isNumeric}}
    {{#isString}}
    {{#maxLength}}
    if({{^required}}value && {{/required}}value{{#required}}.{{/required}}{{^required}}->{{/required}}size() > {{maxLength}}) throw std::runtime_error(std::string("Value has length more than maximum {{maxLength}}! See yaml docs"));
    {{/maxLength}}
    {{#minLength}}
    if({{^required}}value && {{/required}} value{{#required}}.{{/required}}{{^required}}->{{/required}}size() < {{minLength}}) throw std::runtime_error(std::string("Value has length less minimum {{minLength}}! See yaml docs"));
    {{/minLength}}
    {{#vendorExtensions.x-pattern}}
    
    if({{^required}}value && {{/required}} !std::regex_match({{^required}}*{{/required}} value, std::regex("{{#checkparse}}{{vendorExtensions.x-pattern}}{{/checkparse}}"))) 
        throw std::runtime_error(std::string("String is not suitable for regex : {{#checkparse}}{{vendorExtensions.x-pattern}}{{/checkparse}}! See yaml docs"));
    {{/vendorExtensions.x-pattern}}
    {{/isString}}
    {{#isContainer}}
    {{#maxLength}}
    if(value.size() > {{maxLength}}) throw std::runtime_error(std::string("Value has length more than maximum {{maxLength}}! See yaml docs"));
    {{/maxLength}}
    {{#minLength}}
    if(value.size() < {{minLength}}) throw std::runtime_error(std::string("Value has length less minimum {{minLength}}! See yaml docs"));
    {{/minLength}}
    {{/isContainer}}
    this->{{#snakecase}}{{name}}{{/snakecase}} = value;
}
{{/isEnum}}
{{#isEnum}}
{{^vendorExtensions.x-internal}}{{^required}}{{#optional}}{{#camelcase}}e{{name}}{{/camelcase}}{{/optional}}{{/required}}{{#required}}{{#camelcase}}e{{name}}{{/camelcase}}{{/required}}{{/vendorExtensions.x-internal}} 
{{#vendorExtensions.x-internal}}{{classname}}::{{^required}}{{#optional}}{{#camelcase}}e{{name}}{{/camelcase}}{{/optional}}{{/required}}{{#required}}{{#camelcase}}e{{name}}{{/camelcase}}{{/required}}{{/vendorExtensions.x-internal}} 
{{classname}}::{{getter}}() const{
    return this->{{#snakecase}}{{name}}{{/snakecase}};
}
void {{classname}}::{{setter}}({{#camelcase}}e{{name}}{{/camelcase}} value){
    this->{{#snakecase}}{{name}}{{/snakecase}} = value;
}
{{/isEnum}} 
{{/isInherited}}
{{/vars}}
{{#vendorExtensions.x-mongo}}
{{#vars}}
bsoncxx::stdx::optional<mongocxx::result::update>
        {{classname}}::{{name}}UpdateMongo(mongocxx::collection& collection,
                        const bsoncxx::document::view& filter,
                        decltype(document{} << "$set") update){
        auto doc_value = bsoncxx::from_json(fmt::format("{} \"{{#camelcase}}{{name}}{{/camelcase}}\": {} {}","{",toString(ModelBase::toJson({{#snakecase}}{{name}}{{/snakecase}})),"}"));
        auto result = collection.update_one(filter, update <<  doc_value << finalize);
        return result;
}
{{/vars}}
{{/vendorExtensions.x-mongo}}

bool {{classname}}::operator==(const {{classname}}& rhs) const{
    return 
    {{#vars}}
    {{#snakecase}}{{name}}{{/snakecase}} == rhs.{{#snakecase}}{{name}}{{/snakecase}} {{^-last}}&&{{/-last}}
    {{/vars}} 
    {{#allParents}}
    {{#vars}}
    {{#-first}}&&{{/-first}}
    {{/vars}}
    this->{{.}}::operator==(rhs) {{^-last}}&&{{/-last}}
    {{/allParents}}
    ;
}
{{/oneOf}}
{{/isEnum}}


} //{{#modelNamespaceDeclarations}}::{{this}}{{/modelNamespaceDeclarations}}


{{/isConfig}}{{#isConfig}}
{{>Configs/model-source}}
{{/isConfig}}{{/model}}
{{/models}}
