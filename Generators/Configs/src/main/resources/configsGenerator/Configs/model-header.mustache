{{#models}}{{#model}}

{{>licenseInfo}}/*
 * {{classname}}.hpp
 *
 * {{description}}
 */
#pragma once

{{^parent}}
{{{defaultInclude}}}
#include "base-model.hpp"
{{/parent}}
#include "config_interface.hh"

{{#vendorExtensions.x-mongo}}
#include <mongocxx/client.hpp>
#include <bsoncxx/json.hpp>
#include <bsoncxx/builder/stream/document.hpp>
#include <mongocxx/stdx.hpp>
{{/vendorExtensions.x-mongo}}

{{#hasOptional}}
#include <optional>
{{/hasOptional}}
{{#imports}}{{{this}}}
{{/imports}}

#ifdef GENRATE_POCO_DB
namespace Poco::Data{
    class Session;
    class Statement;
}
#endif


namespace {{#modelNamespaceDeclarations}}{{this}}{{^-last}}::{{/-last}}{{/modelNamespaceDeclarations}}{
using namespace std::string_literals;

{{#vendorExtensions.x-mongo}}
using bsoncxx::builder::stream::document;
using bsoncxx::builder::stream::close_array;
using bsoncxx::builder::stream::close_document;
using bsoncxx::builder::stream::finalize;
using bsoncxx::builder::stream::open_array;
using bsoncxx::builder::stream::open_document;
{{/vendorExtensions.x-mongo}}

{{#isEnum}}
class {{declspec}} {{classname}}
    : public {{#parent}}{{{parent}}}{{/parent}}{{^parent}}ModelBase{{/parent}}, public ConfigInterface
{
public:
    
    {{#vendorExtensions.x-postgres-table-name}}
    static constexpr auto kPostgresTableName = "{{vendorExtensions.x-postgres-table-name}}";
    {{/vendorExtensions.x-postgres-table-name}}
    {{#vendorExtensions.x-mongo-collection-name}}
    static constexpr auto kMongoCollectionName = "{{vendorExtensions.x-mongo-collection-name}}";
    {{/vendorExtensions.x-mongo-collection-name}}

    static constexpr auto kName = "{{classname}}";
    {{classname}}();
    virtual ~{{classname}}();


    const std::string GetName() const override{return  kName;};
    const std::string GetPath() const override{return "{{configsFolder}}/"s+kName+".json";};

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;


    {{#vendorExtensions.x-mongo}}
    bsoncxx::document::value toMongoValue();
    bsoncxx::stdx::optional<mongocxx::result::insert_one>
    insertToMongo(mongocxx::collection& collection);

    
    static bsoncxx::stdx::optional<mongocxx::result::insert_many>
     insertToMongoBulk(mongocxx::collection& collection,
                                 const std::vector<{{classname}}>& objects);


    bool fillFromMongo(mongocxx::collection& collection,
                        const bsoncxx::document::view& filter = bsoncxx::document::view{},
                        const mongocxx::options::find& options = mongocxx::options::find{});

   static std::vector<std::shared_ptr<{{classname}}>> fillFromMongoBulk(mongocxx::collection& collection,
                            const bsoncxx::document::view& filter = bsoncxx::document::view{},
                            const mongocxx::options::find& options = mongocxx::options::find{});

    bsoncxx::stdx::optional<mongocxx::result::update>
         updateMongo(mongocxx::collection& collection,
                        const bsoncxx::document::view& filter = bsoncxx::document::view{},
                        decltype(document{} << "$set") update = document{} << "$set");
    {{/vendorExtensions.x-mongo}}

    {{#vendorExtensions.x-postgres-table-name}}
    Poco::Data::Statement   insertToPostgres(std::shared_ptr<Poco::Data::Session> psql_client);
    Poco::Data::Statement   fillFromPostgres(std::shared_ptr<Poco::Data::Session> psql_client,
                            std::optional<std::string> select = std::nullopt,
                            std::optional<std::string> where  = std::nullopt);
    {{/vendorExtensions.x-postgres-table-name}}
    {{#vendorExtensions.x-postgres}}
    {{#vars}}
    {{#vendorExtensions.x-postgres-ref}}
    const {{{dataType}}}& GetPostgresRef() const;
    {{{dataType}}}& GetPostgresRef();
    {{/vendorExtensions.x-postgres-ref}}
    {{/vars}}
    {{/vendorExtensions.x-postgres}}

    enum class e{{classname}}
    {
        {{#allowableValues}}
        {{#enumVars}}
        {{#enumDescription}}
        /// Summary:
        /// {{enumDescription}}
        ///
        {{/enumDescription}}
        k{{{name}}}{{^last}},{{/last}}
        {{/enumVars}}
        {{/allowableValues}}
    };

    bool operator==(const e{{classname}} rhs) const;
    e{{classname}} getValue() const;
    void setValue(e{{classname}} const value);

    protected:
        e{{classname}} value;

    {{#vendorExtensions.x-postgres}}
    //Postgres extension
    friend Poco::Data::TypeHandler<models::{{classname}}>;
    {{/vendorExtensions.x-postgres}}
};
{{/isEnum}}
{{^isEnum}}


{{#vars}}
{{^isInherited}}
{{#isEnum}}
enum class {{#camelcase}}e{{name}}{{/camelcase}}
{
    {{#allowableValues}}
    {{#enumVars}}
    {{#enumDescription}}
    /// Summary:
    /// {{enumDescription}}
    ///
    {{/enumDescription}}
    k{{{name}}}{{^last}},{{/last}}
    {{/enumVars}}
    {{/allowableValues}}
};
web::json::value toJson(const {{#camelcase}}e{{name}}{{/camelcase}} inp_value);
bool fromJson({{#camelcase}}e{{name}}{{/camelcase}}& inp_value, const web::json::value& val);
{{/isEnum}}
{{/isInherited}}
{{/vars}}

/// Summary:
/// {{description}}
///
class {{declspec}} {{classname}}
    : public {{#parent}}{{{parent}}}{{/parent}}{{^parent}}ModelBase{{/parent}}, public ConfigInterface
{
public:
    {{#vendorExtensions.x-postgres-table-name}}
    static constexpr auto kPostgresTableName = "{{vendorExtensions.x-postgres-table-name}}";
    {{/vendorExtensions.x-postgres-table-name}}
    {{#vendorExtensions.x-mongo-collection-name}}
    static constexpr auto kMongoCollectionName = "{{vendorExtensions.x-mongo-collection-name}}";
    {{/vendorExtensions.x-mongo-collection-name}}
    static constexpr auto kName = "{{classname}}";
    {{classname}}();
    virtual ~{{classname}}();


    const std::string GetName() const override{return  kName;};
    const std::string GetPath() const override{return "{{configsFolder}}/"s+kName+".json";};


    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;

    {{#vendorExtensions.x-mongo}}
    bsoncxx::document::value toMongoValue();
    bsoncxx::stdx::optional<mongocxx::result::insert_one>
    insertToMongo(mongocxx::collection& collection);

    
    static bsoncxx::stdx::optional<mongocxx::result::insert_many>
     insertToMongoBulk(mongocxx::collection& collection,
                                 const std::vector<{{classname}}>& objects);


    bool fillFromMongo(mongocxx::collection& collection,
                        const bsoncxx::document::view& filter = bsoncxx::document::view{},
                        const mongocxx::options::find& options = mongocxx::options::find{});

   static std::vector<std::shared_ptr<{{classname}}>> fillFromMongoBulk(mongocxx::collection& collection,
                            const bsoncxx::document::view& filter = bsoncxx::document::view{},
                            const mongocxx::options::find& options = mongocxx::options::find{});

    bsoncxx::stdx::optional<mongocxx::result::update>
         updateMongo(mongocxx::collection& collection,
                        const bsoncxx::document::view& filter = bsoncxx::document::view{},
                        decltype(document{} << "$set") update = document{} << "$set");
    {{/vendorExtensions.x-mongo}}

    {{#vendorExtensions.x-postgres-table-name}}
    Poco::Data::Statement   insertToPostgres(std::shared_ptr<Poco::Data::Session> psql_client);
    Poco::Data::Statement   fillFromPostgres(std::shared_ptr<Poco::Data::Session> psql_client,
                            std::optional<std::string> select = std::nullopt,
                            std::optional<std::string> where  = std::nullopt);
    {{/vendorExtensions.x-postgres-table-name}}
    {{#vendorExtensions.x-postgres}}
    {{#vars}}
    {{#vendorExtensions.x-postgres-ref}}
    const {{{dataType}}}& GetPostgresRef() const;
    {{{dataType}}}& GetPostgresRef();
    {{/vendorExtensions.x-postgres-ref}}
    {{/vars}}
    {{/vendorExtensions.x-postgres}}

    /////////////////////////////////////////////
    /// {{classname}} members
    
    bool operator==(const {{classname}}& rhs) const;

    {{#vars}}
    {{^isInherited}}
    /// Summary:
    /// {{description}}
    ///{{^isEnum}}
    {{#isContainer}}{{{dataType}}}& {{getter}}();{{/isContainer}}
    {{^isContainer}}{{^required}}{{#optional}}{{{dataType}}}{{/optional}}{{/required}}{{#required}}{{{dataType}}}{{/required}}   {{getter}}() const;{{/isContainer}}
    {{#isPrimitiveType}}
    void {{setter}}({{{dataType}}} value);
    {{/isPrimitiveType}}
    {{^isPrimitiveType}}
    void {{setter}}(const {{{dataType}}}& value);
    {{/isPrimitiveType}}
    {{/isEnum}}{{/isInherited}} 
    {{#isEnum}}
    {{^required}}{{#optional}}{{#camelcase}}e{{name}}{{/camelcase}}{{/optional}}{{/required}}{{#required}}{{#camelcase}}e{{name}}{{/camelcase}}{{/required}} {{getter}}() const;
    void {{setter}}({{#camelcase}}e{{name}}{{/camelcase}} value);
    {{/isEnum}} 
    {{/vars}}

    {{#vendorExtensions.x-mongo}}
    {{#vars}}
    bsoncxx::stdx::optional<mongocxx::result::update>
    {{name}}UpdateMongo(mongocxx::collection& collection,
                    const bsoncxx::document::view& filter = bsoncxx::document::view{},
                    decltype(document{} << "$set") update = document{} << "$set");
    {{/vars}}
    {{/vendorExtensions.x-mongo}}
    

protected:
    {{#vars}}
    {{^isInherited}}
    {{^isEnum}}
    {{^required}}{{^isContainer}}{{#optional}}{{{dataType}}}{{/optional}}{{/isContainer}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{/required}}{{#required}}{{{dataType}}}{{/required}}  {{#snakecase}}{{name}}{{/snakecase}};
    {{/isEnum}}
    {{#isEnum}}
    {{^required}}{{#optional}}{{#camelcase}}e{{name}}{{/camelcase}}{{/optional}}{{/required}}{{#required}}{{#camelcase}}e{{name}}{{/camelcase}}{{/required}}  {{#snakecase}}{{name}}{{/snakecase}};
    {{/isEnum}}
    {{/isInherited}}
    {{/vars}}
    
    {{#vendorExtensions.x-postgres}}
    //Postgres extension
    {{#vars}}
    {{#isContainer}}
    mutable std::string {{#snakecase}}{{name}}{{/snakecase}}Buffer;
    {{/isContainer}}
    {{#isUuid}}
    mutable std::string {{#snakecase}}{{name}}{{/snakecase}}Buffer;
    {{/isUuid}}
    {{/vars}}
    friend Poco::Data::TypeHandler<models::{{classname}}>;
    {{/vendorExtensions.x-postgres}}
};

{{/isEnum}}


} //{{#modelNamespaceDeclarations}}::{{this}}{{/modelNamespaceDeclarations}}


{{#vendorExtensions.x-postgres}}
namespace Poco::Data{


template <>
class TypeHandler<models::{{classname}}>
	/// Defining a specialization of TypeHandler for Person allows us
	/// to use the Person struct in use and into clauses.
{
public:
	static std::size_t size()
	{
		return 
        {{#vars}}{{^-last}}1+{{/-last}}{{#-last}}1{{/-last}}{{/vars}};
	}
	
	static void bind(std::size_t pos,const models::{{classname}}& obj, AbstractBinder::Ptr pBinder, AbstractBinder::Direction dir)
	{      
        {{#vars}}
        {{#isListContainer}}
        obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer = std::move(models::ModelBase::toString(obj.{{#snakecase}}{{name}}{{/snakecase}}, true));
        TypeHandler<std::string>::bind(pos++,obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,pBinder, dir);
        {{/isListContainer}}
        {{#isMapContainer}}
        obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer = std::move(models::ModelBase::toString(obj.{{#snakecase}}{{name}}{{/snakecase}}));
        TypeHandler<std::string>::bind(pos++,obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,pBinder, dir);
        {{/isMapContainer}}
        {{#isUuid}}
        obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer = std::move(models::ModelBase::toString(obj.{{#snakecase}}{{name}}{{/snakecase}}));
        TypeHandler<std::string>::bind(pos++,obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,pBinder, dir);
        {{/isUuid}}

        {{#isModel}}
        static_assert(IsPostgresRefereneble<{{baseType}}>, "Model {{classname}} has reference to {{baseType}}, but {{{baseType}}} has no variable with tag x-postgres-ref");
        if(obj.{{#snakecase}}{{name}}{{/snakecase}}){
            auto& ref = obj.{{#snakecase}}{{name}}{{/snakecase}}->GetPostgresRef();
            TypeHandler<decltype(ref)>::bind(pos++, ref,pBinder, dir);
        }
        {{/isModel}}

        {{^isModel}}
        {{^isContainer}}
        {{^isUuid}}
        TypeHandler<{{^required}}{{^isContainer}}std::optional<{{/isContainer}}{{/required}}{{{dataType}}}{{^required}}{{^isContainer}}>{{/isContainer}}{{/required}}>::bind(pos++, obj.{{#snakecase}}{{name}}{{/snakecase}},pBinder, dir);
        {{/isUuid}}
        {{/isContainer}}
        {{/isModel}}
        {{/vars}}
	}
	
	static void extract(std::size_t pos, models::{{classname}}& obj, const models::{{classname}}& deflt, AbstractExtractor::Ptr pExtr)
	{
        {{#vars}}
        {{#isListContainer}}
        TypeHandler<std::string>::extract(pos++, obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,{}, pExtr);
        models::ModelBase::fromString(obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,obj.{{#snakecase}}{{name}}{{/snakecase}}, true);
        {{/isListContainer}}
        {{#isMapContainer}}
        TypeHandler<std::string>::extract(pos++, obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,{}, pExtr);
        models::ModelBase::fromString(obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,obj.{{#snakecase}}{{name}}{{/snakecase}});
        {{/isMapContainer}}
        {{#isUuid}}
        TypeHandler<std::string>::extract(pos++, obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,{}, pExtr);
        models::ModelBase::fromString(obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,obj.{{#snakecase}}{{name}}{{/snakecase}});
        {{/isUuid}}


        {{#isModel}}
        {
        static_assert(IsPostgresRefereneble<{{baseType}}>, "Model {{classname}} has reference to {{baseType}}, but {{{baseType}}} has no variable with tag x-postgres-ref");
        if(!obj.{{#snakecase}}{{name}}{{/snakecase}})
        obj.{{#snakecase}}{{name}}{{/snakecase}} = std::make_shared<{{baseType}}>();
        auto& ref = obj.{{#snakecase}}{{name}}{{/snakecase}}->GetPostgresRef();
        TypeHandler<decltype(ref)>::extract(pos++, ref, ref,pExtr);
        }
        {{/isModel}}
        
        {{^isModel}}
        {{^isContainer}}
        {{^isInherited}}
        {{^isUuid}}
        TypeHandler<{{^required}}{{^isContainer}}std::optional<{{/isContainer}}{{/required}}{{{dataType}}}{{^required}}{{^isContainer}}>{{/isContainer}}{{/required}}>::extract(pos++, obj.{{#snakecase}}{{name}}{{/snakecase}},deflt.{{#snakecase}}{{name}}{{/snakecase}}, pExtr);
        {{/isUuid}}
        {{/isInherited}}
        {{/isContainer}}
        {{/isModel}}
        {{/vars}}
	}
	
	static void prepare(std::size_t pos, const models::{{classname}}& obj, AbstractPreparator::Ptr pPrep)
	{
        {{#vars}}
        {{#isListContainer}}
        obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer = std::move(models::ModelBase::toString(obj.{{#snakecase}}{{name}}{{/snakecase}}, true));
        TypeHandler<std::string>::prepare(pos++,obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,pPrep);
        {{/isListContainer}}
        {{#isMapContainer}}
        obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer = std::move(models::ModelBase::toString(obj.{{#snakecase}}{{name}}{{/snakecase}}));
        TypeHandler<std::string>::prepare(pos++,obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,pPrep);
        {{/isMapContainer}}
        {{#isUuid}}
        obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer = std::move(models::ModelBase::toString(obj.{{#snakecase}}{{name}}{{/snakecase}}));
        TypeHandler<std::string>::prepare(pos++,obj.{{#snakecase}}{{name}}{{/snakecase}}Buffer,pPrep);
        {{/isUuid}}

        {{#isModel}}
        if(!obj.{{#snakecase}}{{name}}{{/snakecase}}){
            static_assert(IsPostgresRefereneble<{{baseType}}>, "Model {{classname}} has reference to {{baseType}}, but {{{baseType}}} has no variable with tag x-postgres-ref");
            auto& ref = obj.{{#snakecase}}{{name}}{{/snakecase}}->GetPostgresRef();
            TypeHandler<decltype(ref)>::prepare(pos++,ref,pPrep);
        }
        {{/isModel}}

        {{^isModel}}
        {{^isContainer}}
        {{^isInherited}}
        {{^isUuid}}
        TypeHandler<{{^required}}{{^isContainer}}std::optional<{{/isContainer}}{{/required}}{{{dataType}}}{{^required}}{{^isContainer}}>{{/isContainer}}{{/required}}>::prepare(pos++, obj.{{#snakecase}}{{name}}{{/snakecase}},pPrep);
        {{/isUuid}}
        {{/isInherited}}
        {{/isContainer}}
        {{/isModel}}
        {{/vars}}
	}
};
}
{{/vendorExtensions.x-postgres}}
{{/model}}
{{/models}}

